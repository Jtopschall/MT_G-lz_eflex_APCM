import asyncio
import logging
from asyncua import Client, Node, ua, Server
import time
from datetime import timedelta, datetime, date, timezone
from termcolor import colored
import xml.etree.ElementTree as ET
from entsoe import EntsoeRawClient
import pandas as pd
import json
import uuid
import os
import bivalent_betreiben_aktivieren
import bivalent_betreiben_deaktivieren

# logging.basicConfig(level=logging.INFO)


# create global server object and specify nodeset files the server is based on, change server_url to run on other machines:
server = Server()
server_url = 'opc.tcp://127.0.0.1:4840'

# paths to all nodesets
DI_path = "C:/Users/j.goelz/poser-eflex-apcm/Implementierung/CentralServerETA/Opc.Ua.Di.NodeSet2.xml"
IA_path = "C:/Users/j.goelz/poser-eflex-apcm/Implementierung/CentralServerETA/Opc.Ua.IA.NodeSet2.xml"
Machinery_path = "C:/Users/j.goelz/poser-eflex-apcm/Implementierung/CentralServerETA/Opc.Ua.Machinery.NodeSet2.xml"
MT_path = "C:/Users/j.goelz/poser-eflex-apcm/Implementierung/CentralServerETA/Opc.Ua.MachineTool.NodeSet2.xml"
CO2_path = "C:/Users/j.goelz/poser-eflex-apcm/Implementierung/CentralServerETA/adp_mt_co2.xml"
EnFlex_path = "C:/Users/j.goelz/poser-eflex-apcm/Implementierung/CentralServerETA/opc_ua_for_enflex.xml"
CentralServer_path = "C:/Users/j.goelz/poser-eflex-apcm/Implementierung/CentralServerETA/centralserver.xml"

################################################################entso-e config start

# setup entso-e client api and bidding zone
entsoe_client = EntsoeRawClient(api_key='2bf35639-fb7f-4c52-a2ae-1debcf0a058e')
country_code = 'DE_LU'

# config for current electricity mix: timedelta to retrieve values of the slowest PsrTypes:
# ElMix_start = pd.Timestamp(pd.Timestamp.now(), tz='Europe/Brussels') + timedelta(days=-1, hours=-2) #days -5 while testing on weekend / hours-5
# ElMix_end = pd.Timestamp(pd.Timestamp.now(), tz='Europe/Brussels' )

# for validation / testing:
ElMix_start = pd.Timestamp.now(tz='Europe/Brussels').replace(hour=0, minute=0, second=0, microsecond=0,
                                                             nanosecond=0) + timedelta(days=-7,
                                                                                       hours=-1)  # days -6 while testing on weekend / hours-5
ElMix_end = pd.Timestamp.now(tz='Europe/Brussels').replace(hour=0, minute=0, second=0, microsecond=0,
                                                           nanosecond=0) + timedelta(days=-7, hours=+1)
CEF_list = []

start_times = []
end_times = []

# Uhrzeit einstellen: 15 Minuten vor Ende der jeweiligen Schicht
final_check_time = pd.Timestamp.now(tz='Europe/Brussels').replace(hour=13, minute=45, second=0, microsecond=0)

# config for day ahead data: day 00:00 + 24h
DA_start = pd.Timestamp.now(tz='Europe/Brussels').replace(hour=0, minute=0, second=0, microsecond=0,
                                                          nanosecond=0)
DA_end = DA_start + timedelta(hours=24)
print("DA_start:", DA_start)
print("DA_end:", DA_end)
# psr dicts (dicts should be generated by server for increased robustness):
psr_type_dict = {'Biomass': 'B01', 'BrownCoal': 'B02', 'NaturalGas': 'B04', 'BlackCoal': 'B05', 'PumpedStorage': 'B10',
                 'HydroElectric': 'B11', 'MiscRenewables': 'B15', 'Solar': 'B16', 'WindOffshore': 'B18',
                 'WindOnshore': 'B19'}

Energy_generation_dict = {'Biomass_gen': 6018, 'BrownCoal_gen': 6159, 'NaturalGas_gen': 6162, 'BlackCoal_gen': 6165,
                          'PumpedStorage_gen': 6168, 'HydroElectric_gen': 6171, 'Nuclear_gen': 6174,
                          'MiscRenewables_gen': 6177, 'Solar_gen': 6180, 'WindOffshore_gen': 6183,
                          'WindOnshore_gen': 6186}

Energy_share_dict = {'Biomass_share': 6019, 'BrownCoal_share': 6160, 'NaturalGas_share': 6163, 'BlackCoal_share': 6166,
                     'PumpedStorage_share': 6169, 'HydroElectric_share': 6172, 'Nuclear_share': 6175,
                     'MiscRenewables_share': 6178, 'Solar_share': 6181, 'WindOffshore_share': 6184,
                     'WindOnshore_share': 6187}

Emission_factors_dict = {'Biomass_factor': 0.023, 'BrownCoal_factor': 1.135, 'NaturalGas_factor': 0.49,
                         'BlackCoal_factor': 0.852, 'PumpedStorage_factor': 0.851, 'HydroElectric_factor': 0.004,
                         'Nuclear_factor': 0.022, 'MiscRenewables_factor': 0.01, 'Solar_factor': 0.056,
                         'WindOffshore_factor': 0.01, 'WindOnshore_factor': 0.018}

# timeframe dicts (dicts should be generated by server for increased robustness):
tf_start_dict = {'tf1_start': 6011, 'tf2_start': 6020, 'tf3_start': 6026, 'tf4_start': 6032, 'tf5_start': 6038,
                 'tf6_start': 6044, 'tf7_start': 6050, 'tf8_start': 6056, 'tf9_start': 6062, 'tf10_start': 6068,
                 'tf11_start': 6074, 'tf12_start': 6080, 'tf13_start': 6086, 'tf14_start': 6092, 'tf15_start': 6098,
                 'tf16_start': 6104, 'tf17_start': 6110, 'tf18_start': 6116, 'tf19_start': 6122, 'tf20_start': 6128,
                 'tf21_start': 6134, 'tf22_start': 6140, 'tf23_start': 6146, 'tf24_start': 6152}

tf_price_dict = {'tf1_price': 6012, 'tf2_price': 6021, 'tf3_price': 6027, 'tf4_price': 6033, 'tf5_price': 6039,
                 'tf6_price': 6045, 'tf7_price': 6051, 'tf8_price': 6057, 'tf9_price': 6063, 'tf10_price': 6069,
                 'tf11_price': 6075, 'tf12_price': 6081, 'tf13_price': 6087, 'tf14_price': 6093, 'tf15_price': 6099,
                 'tf16_price': 6105, 'tf17_price': 6111, 'tf18_price': 6117, 'tf19_price': 6123, 'tf20_price': 6129,
                 'tf21_price': 6135, 'tf22_price': 6141, 'tf23_price': 6147, 'tf24_price': 6153}

tf_end_dict = {'tf1_end': 6013, 'tf2_end': 6022, 'tf3_end': 6028, 'tf4_end': 6034, 'tf5_end': 6040, 'tf6_end': 6046,
               'tf7_end': 6052, 'tf8_end': 6058, 'tf9_end': 6064, 'tf10_end': 6070, 'tf11_end': 6076, 'tf12_end': 6082,
               'tf13_end': 6088, 'tf14_end': 6094, 'tf15_end': 6100, 'tf16_end': 6106, 'tf17_end': 6112,
               'tf18_end': 6118, 'tf19_end': 6124, 'tf20_end': 6130, 'tf21_end': 6136, 'tf22_end': 6142,
               'tf23_end': 6148, 'tf24_end': 6154}

tf_TotalGen_dict = {'tf1_totalGen': 6014, 'tf2_totalGen': 6023, 'tf3_totalGen': 6029, 'tf4_totalGen': 6035,
                    'tf5_totalGen': 6041, 'tf6_totalGen': 6047, 'tf7_totalGen': 6053, 'tf8_totalGen': 6059,
                    'tf9_totalGen': 6065, 'tf10_totalGen': 6071, 'tf11_totalGen': 6077, 'tf12_totalGen': 6083,
                    'tf13_totalGen': 6089, 'tf14_totalGen': 6095, 'tf15_totalGen': 6101, 'tf16_totalGen': 6107,
                    'tf17_totalGen': 6113, 'tf18_totalGen': 6119, 'tf19_totalGen': 6125, 'tf20_totalGen': 6131,
                    'tf21_totalGen': 6137, 'tf22_totalGen': 6143, 'tf23_totalGen': 6149, 'tf24_totalGen': 6155}

tf_WSGen_dict = {'tf1_WSGen': 6015, 'tf2_WSGen': 6024, 'tf3_WSGen': 6030, 'tf4_WSGen': 6036, 'tf5_WSGen': 6042,
                 'tf6_WSGen': 6048, 'tf7_WSGen': 6054, 'tf8_WSGen': 6060, 'tf9_WSGen': 6066, 'tf10_WSGen': 6072,
                 'tf11_WSGen': 6078, 'tf12_WSGen': 6084, 'tf13_WSGen': 6090, 'tf14_WSGen': 6096, 'tf15_WSGen': 6102,
                 'tf16_WSGen': 6108, 'tf17_WSGen': 6114, 'tf18_WSGen': 6120, 'tf19_WSGen': 6126, 'tf20_WSGen': 6132,
                 'tf21_WSGen': 6138, 'tf22_WSGen': 6144, 'tf23_WSGen': 6150, 'tf24_WSGen': 6156}

tf_WSPercent_dict = {'tf1_WSPercent': 6016, 'tf2_WSPercent': 6025, 'tf3_WSPercent': 6031, 'tf4_WSPercent': 6037,
                     'tf5_WSPercent': 6043, 'tf6_WSPercent': 6049, 'tf7_WSPercent': 6055, 'tf8_WSPercent': 6061,
                     'tf9_WSPercent': 6067, 'tf10_WSPercent': 6073, 'tf11_WSPercent': 6079, 'tf12_WSPercent': 6085,
                     'tf13_WSPercent': 6091, 'tf14_WSPercent': 6097, 'tf15_WSPercent': 6103, 'tf16_WSPercent': 6109,
                     'tf17_WSPercent': 6115, 'tf18_WSPercent': 6121, 'tf19_WSPercent': 6127, 'tf20_WSPercent': 6133,
                     'tf21_WSPercent': 6139, 'tf22_WSPercent': 6145, 'tf23_WSPercent': 6151, 'tf24_WSPercent': 6157}

# create nodeIDs from Energy_generation_dict:
for k, v in Energy_generation_dict.items():
    globals()['CentralServer_id_' + k] = ua.NodeId(v, 8)

# create nodeIDs from Energy_share_dict:
for k, v in Energy_share_dict.items():
    globals()['CentralServer_id_' + k] = ua.NodeId(v, 8)

# create nodeIDs from tf_start_dict:
for k, v in tf_start_dict.items():
    globals()['CentralServer_id_' + k] = ua.NodeId(v, 8)

# create nodeIDs from tf_price_dict:
for k, v in tf_price_dict.items():
    globals()['CentralServer_id_' + k] = ua.NodeId(v, 8)

# create nodeIDs from tf_end_dict:
for k, v in tf_end_dict.items():
    globals()['CentralServer_id_' + k] = ua.NodeId(v, 8)

# create nodeIDs from tf_TotalGen_dict:
for k, v in tf_TotalGen_dict.items():
    globals()['CentralServer_id_' + k] = ua.NodeId(v, 8)

# create nodeIDs from tf_WSGen_dict:
for k, v in tf_WSGen_dict.items():
    globals()['CentralServer_id_' + k] = ua.NodeId(v, 8)

# create nodeIDs from tf_WSPercent_dict:
for k, v in tf_WSPercent_dict.items():
    globals()['CentralServer_id_' + k] = ua.NodeId(v, 8)

################################################################flexLoad config start

# flexloadID dict
flexloadID_dict = {
    "Heizstab_ST_12": "d162e83e-abbd-11ee-bb33-6003088b0288",
    "Heizstab_ST_34": "dc5d3190-abbd-11ee-b8be-6003088b0288",
    "Heizstab_ST_5": "e8afa00e-abbd-11ee-90fc-6003088b0288",
    "Heizstab_WT_12": "f3d5cea4-abbd-11ee-b295-6003088b0288",
    "Heizstab_WT_34": "07d6e686-abbe-11ee-b37d-6003088b0288",
    "Heizstab_WT_5": "0eac2192-abbe-11ee-b3f4-6003088b0288",
    "IR_Strahler_14": "169b0fa8-abbe-11ee-9706-6003088b0288",
    "IR_Strahler_23": "296844b6-abbe-11ee-afac-6003088b0288"
}

# measures_folder = 'Implementierung/MeasuresExchangeFolder'
measures_folder = "C:/Users/j.goelz/poser-eflex-apcm/Implementierung/MeasuresExchangeFolder"



def clear_old_measures(folder):
    # Lösche alle Dateien im angegebenen Verzeichnis
    for filename in os.listdir(folder):
        file_path = os.path.join(folder, filename)
        try:
            if os.path.isfile(file_path) and filename.endswith('.json'):
                os.unlink(file_path)
                print(f"Deleted old measure file: {file_path}")
        except Exception as e:
            print(f"Error deleting file {file_path}: {e}")


# Call the function to clear old measures at the start
clear_old_measures(measures_folder)

# global counter for naming measure files, incremented by gen fun
measures_counter = 1

# global counter for naming measure files, incremented by gen fun
measures_counter = 1


###################################################################entso-e funs start

# function to query a single energy production type using configured entsoe_client
def query_EnergyProductionType(type):
    try:
        xml_string = entsoe_client.query_generation(country_code, ElMix_start, ElMix_end, psr_type=type)
    except Exception as e:
        print(e)
    root = ET.fromstring(xml_string)
    values = []

    # i hope the stuff in {} does not change '*quantity' does not work:
    for pos in root.iter('{urn:iec62325.351:tc57wg16:451-6:generationloaddocument:3:0}quantity'):
        values.append(pos.text)

    # Reduce faster PsrTypes to same timeframe as first PsrType (Biomass)
    if type == 'B01':
        globals()['length_of_values'] = (len(values))
    del values[int(length_of_values):]

    # calculate average of last hour
    last_hour_average = (float(values[-1]) + float(values[-2]) + float(values[-3]) + float(values[-4])) / 4

    # for testing what values are retrieved from entsoe:
    # print(type + str(values))

    # Calling the function returns the last hour average of specified production type
    return (last_hour_average)


# this is the psr updater: queries entsoe and calculates production shares
async def CurrentMix_updater():
    averages = []

    try:
        for v in psr_type_dict.values():
            averages.append(query_EnergyProductionType(v))
        # calcualte TotalEnergyProduction
        TotalEnergyProduction = sum(averages)
    except Exception as e:
        print(v, e)

    # write total energy generation to node:
    await globals()['CentralServer_N_total_energy_generation'].set_value(TotalEnergyProduction)

    # directly write node values for generation
    for k, v in zip(Energy_generation_dict.keys(), averages):
        await globals()['CentralServer_N_' + k].set_value(v)

    # Calculate shares
    globals()['SharesOfTotalEnergy'] = [x / TotalEnergyProduction for x in averages]

    # directly write node values for shares
    for k, v in zip(Energy_share_dict.keys(), SharesOfTotalEnergy):
        await globals()['CentralServer_N_' + k].set_value(v)

    # calculate total carbon emission factor for all EnergyProductionTypes combined (in CO2-eq/kWh)
    globals()['Total_Carbon_Emission_Factor'] = sum(
        [ef * se for ef, se in zip(Emission_factors_dict.values(), SharesOfTotalEnergy)])

    # write total carbon emission factor to node:
    await globals()['CentralServer_N_total_carbon_emission_factor'].set_value(globals()['Total_Carbon_Emission_Factor'])

    # give user feedback, since no return value
    print('psr types successfully queried')

    # for testing:
    # print(globals()['SharesOfTotalEnergy'])
    # print('###################')
    # print('from '+str(ElMix_start))
    # print('to '+str(ElMix_end))
    # globals()['CEF_list'].append(globals()['Total_Carbon_Emission_Factor'])
    # print(globals()['CEF_list'])
    # print('###################')


# Function to connect and read temperatures from Beckhoffserver (Wasch- und Spültank):
async def read_tank_temperatures():
    # setup client connecting to Beckhoff PLC
    Beckhoff_DLRA_Server_url = 'opc.tcp://192.168.116.129:4840'
    Beckhoff_DLRA_Server_client = Client(url=Beckhoff_DLRA_Server_url)

    try:
        await Beckhoff_DLRA_Server_client.connect()
        print('Successfully connected to the Beckhoff server')

        # read nodes

        node_BvL_HeizTankModus_control_bManualModeActivated = Beckhoff_DLRA_Server_client.get_node(
            "ns=4;s=MAIN.VarPOU_LoTuS.LoTuS.DAK.BvL_Tanks.BvL_Tank_RZ.Tankheizung.BvL_T_T.sensorState.fValue")

        node_BvL_HeizTankModus_control_bManualModeActivated2 = Beckhoff_DLRA_Server_client.get_node(
            "ns=4;s=MAIN.VarPOU_LoTuS.LoTuS.DAK.BvL_Tanks.BvL_Tank_SZ.Tankheizung.BvL_T_T.sensorState.fValue")

        # Read Values
        Temp_WT = await node_BvL_HeizTankModus_control_bManualModeActivated.read_value()
        Temp_SP = await node_BvL_HeizTankModus_control_bManualModeActivated2.read_value()

    except Exception as e:
        print(f"Failed to connect to the Beckhoff server: {e}")
        Temp_WT = 45.0
        Temp_SP = 51.0

    finally:
        try:
            await Beckhoff_DLRA_Server_client.disconnect()
        except Exception as e:
            print(f"Error during disconnection: {e}")

    return round(Temp_WT, 5), round(Temp_SP, 5)


async def sleep_until(target_time):
    current_time = datetime.now()
    sleep_duration = (target_time - current_time).total_seconds()
    if sleep_duration > 0:
        await asyncio.sleep(sleep_duratio)


async def query_DayAhead_prices():
    xml_string = entsoe_client.query_day_ahead_prices(country_code, DA_start, DA_end)
    print(DA_start)
    print(DA_end)
    root = ET.fromstring(xml_string)
    globals()['El_Price_list'] = []
    globals()['El_Price_list_15M'] = []

    for period in root.iter('{urn:iec62325.351:tc57wg16:451-3:publicationdocument:7:0}Period'):
        res = period.find('{urn:iec62325.351:tc57wg16:451-3:publicationdocument:7:0}resolution')
        if res.text == 'PT60M':
            for val in period.iter('{urn:iec62325.351:tc57wg16:451-3:publicationdocument:7:0}price.amount'):
                globals()['El_Price_list'].append(float(val.text))

        if res.text == 'PT15M':
            for val in period.iter('{urn:iec62325.351:tc57wg16:451-3:publicationdocument:7:0}price.amount'):
                globals()['El_Price_list_15M'].append(float(val.text))

                print(
                    val.text)  # array hinzufügen - einen erstellen und als globale variable dann hab ich überall Zugriff drauf
                print("15M Prices:", globals()['El_Price_list_15M'])

    # directly write node values for prices
    for k, v in zip(tf_price_dict.keys(), globals()['El_Price_list']):
        await globals()['CentralServer_N_' + k].set_value(v)

    # for testing
    # print(dict(zip(tf_price_dict.keys(), globals()['El_Price_list'])))

    # give user feedback, since no return value
    print('day ahead prices successfully queried')


# query day ahead total generation
async def query_Generation():
    xml_string = entsoe_client.query_generation_forecast(country_code, DA_start, DA_end)
    root = ET.fromstring(xml_string)
    globals()['DA_Generation'] = []

    for pos in root.iter('{urn:iec62325.351:tc57wg16:451-6:generationloaddocument:3:0}quantity'):
        globals()['DA_Generation'].append(float(pos.text))

    # directly write node values for total generation
    for k, v in zip(tf_TotalGen_dict.keys(), globals()['DA_Generation']):
        await globals()['CentralServer_N_' + k].set_value(v)

    # give user feedback, since no return value
    print('day ahead generation successfully queried')

    # for testing:
    # print(values)


# query day ahead wind and solar genertion, also calculate percent of total energy generation for timeframes
async def query_WindSolar():
    global DA_Generation
    global DA_WS_Generation

    xml_string = entsoe_client.query_wind_and_solar_forecast(country_code, DA_start, DA_end)
    root = ET.fromstring(xml_string)

    # this returns values for 15 min intervals
    Wind_OnS_values15 = []
    Wind_OffS_values15 = []
    Solar_values15 = []

    for ts in root.iter('{urn:iec62325.351:tc57wg16:451-6:generationloaddocument:3:0}TimeSeries'):
        mkt = ts.find('{urn:iec62325.351:tc57wg16:451-6:generationloaddocument:3:0}MktPSRType')
        psr = mkt.find('{urn:iec62325.351:tc57wg16:451-6:generationloaddocument:3:0}psrType')
        if psr.text == 'B16':
            for val in ts.iter('{urn:iec62325.351:tc57wg16:451-6:generationloaddocument:3:0}quantity'):
                Solar_values15.append(float(val.text))
        elif psr.text == 'B18':
            for val in ts.iter('{urn:iec62325.351:tc57wg16:451-6:generationloaddocument:3:0}quantity'):
                Wind_OffS_values15.append(float(val.text))
        elif psr.text == 'B19':
            for val in ts.iter('{urn:iec62325.351:tc57wg16:451-6:generationloaddocument:3:0}quantity'):
                Wind_OnS_values15.append(float(val.text))

    # turn 15 min intervals to 60 min intervals by hourly averaging
    Solar_values60 = []
    Wind_OffS_values60 = []
    Wind_OnS_values60 = []
    i = 0
    while i < (len(Solar_values15)):
        Solar_values60.append(
            (Solar_values15[i] + Solar_values15[i + 1] + Solar_values15[i + 2] + Solar_values15[i + 3]) / 4)
        Wind_OffS_values60.append((Wind_OffS_values15[i] + Wind_OffS_values15[i + 1] + Wind_OffS_values15[i + 2] +
                                   Wind_OffS_values15[i + 3]) / 4)
        Wind_OnS_values60.append(
            (Wind_OnS_values15[i] + Wind_OnS_values15[i + 1] + Wind_OnS_values15[i + 2] + Wind_OnS_values15[i + 3]) / 4)
        i += 4

    # summarize solar and wind generation
    globals()['DA_WS_Generation'] = []
    i = 0
    while i < (len(Solar_values60)):
        globals()['DA_WS_Generation'].append(Solar_values15[i] + Wind_OffS_values15[i] + Wind_OnS_values15[i])
        i += 1

    # directly write node values for wind and solar generation
    for k, v in zip(tf_WSGen_dict.keys(), globals()['DA_WS_Generation']):
        await globals()['CentralServer_N_' + k].set_value(v)

    # calculate percent of total energy for timeframes
    globals()['DA_WS_Percentage'] = []
    i = 0
    while i < (len(globals()['DA_WS_Generation'])):
        globals()['DA_WS_Percentage'].append(DA_WS_Generation[i] / DA_Generation[i])
        i += 1

    # directly write node values for wind and solar percentage
    for k, v in zip(tf_WSPercent_dict.keys(), globals()['DA_WS_Percentage']):
        await globals()['CentralServer_N_' + k].set_value(v)

    # give user feedback, since no return value
    print('day ahead wind and solar generation successfully queried')

    # for testing:
    # print(Solar_values60)
    # print(Wind_OffS_values60)
    # print(Wind_OnS_values60)


#######################################################################efdm generation starts

# this is the fun to generate a new efdm measures file in json format, needs global measures counter:
def gen_efdm(flexLoad: str, onValue: float, onTime: datetime, offValue: float, offTime: datetime, reward: float):
    global measures_counter

    # All the values/args for the JSON file:
    metadata_instanceId = str(uuid.uuid4())
    metadata_origin_originId = str(uuid.uuid4())
    metadata_origin_timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    metadata_modification_modifierId = str(uuid.uuid4())
    metadata_modification_timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    metadata_comment = "an efdm measure file"

    flexibleLoadMeasures_flexibleLoadMeasureId = str(uuid.uuid4())
    flexibleLoadMeasures_flexibleLoadId = flexloadID_dict[flexLoad]

    on_value = onValue
    on_timestamp = onTime.strftime("%Y-%m-%dT%H:%M:%SZ")
    off_value = offValue
    off_timestamp = offTime.strftime("%Y-%m-%dT%H:%M:%SZ")
    flexibleLoadMeasures_reward = reward

    # Load the blueprint
    with open(
            "C:/Users/j.goelz/poser-eflex-apcm/Implementierung/CentralServerETA/efdm_measure_blueprint.json",
            'r') as file:
        data = json.load(file)

    # Edit existing fields
    data["metadata"]["instanceId"] = metadata_instanceId
    data["metadata"]["origin"]["originId"] = metadata_origin_originId
    data["metadata"]["origin"]["timestamp"] = metadata_origin_timestamp
    data["metadata"]["modification"]["modifierId"] = metadata_modification_modifierId
    data["metadata"]["modification"]["timestamp"] = metadata_modification_timestamp
    data["metadata"]["comment"] = metadata_comment

    data["flexibleLoadMeasures"][0]["flexibleLoadMeasureId"]["uuid"] = flexibleLoadMeasures_flexibleLoadMeasureId
    data["flexibleLoadMeasures"][0]["flexibleLoadId"]["uuid"] = flexibleLoadMeasures_flexibleLoadId

    data["flexibleLoadMeasures"][0]["loadChangeProfile"][0]["power"]["unit"] = "W"
    data["flexibleLoadMeasures"][0]["loadChangeProfile"][0]["power"]["value"] = off_value
    data["flexibleLoadMeasures"][0]["loadChangeProfile"][0]["timestamp"] = on_timestamp

    data["flexibleLoadMeasures"][0]["loadChangeProfile"][1]["power"]["unit"] = "W"
    data["flexibleLoadMeasures"][0]["loadChangeProfile"][1]["power"]["value"] = on_value
    data["flexibleLoadMeasures"][0]["loadChangeProfile"][1]["timestamp"] = on_timestamp

    # Create fields to append (blueprint already has load change 0 and load change 1)
    load_change_2 = {
        "power": {
            "unit": "W",
            "value": on_value
        },
        "timestamp": off_timestamp
    }

    load_change_3 = {
        "power": {
            "unit": "W",
            "value": off_value
        },
        "timestamp": off_timestamp
    }

    # Append fields
    data["flexibleLoadMeasures"][0]["loadChangeProfile"].append(load_change_2)
    data["flexibleLoadMeasures"][0]["loadChangeProfile"].append(load_change_3)

    # Edit existing reward field
    data["flexibleLoadMeasures"][0]["reward"]["value"] = flexibleLoadMeasures_reward

    # Values to check if changed
    new_profile = data["flexibleLoadMeasures"][0]["loadChangeProfile"]
    new_flex_load_id = data["flexibleLoadMeasures"][0]["flexibleLoadId"]["uuid"]
    new_reward = data["flexibleLoadMeasures"][0]["reward"]

    # Create JSON dump for new file from modified data
    new_data = json.dumps(data, indent=4)

    # Check for existing measures
    measures_folder = "C:/Users/j.goelz/poser-eflex-apcm/Implementierung/MeasuresExchangeFolder"
    for filename in os.listdir(measures_folder):
        if filename.endswith(".json"):
            with open(os.path.join(measures_folder, filename), 'r') as oldfile:
                old_data = json.load(oldfile)
                old_profile = old_data["flexibleLoadMeasures"][0]["loadChangeProfile"]
                old_flex_load_id = old_data["flexibleLoadMeasures"][0]["flexibleLoadId"]["uuid"]
                old_reward = old_data["flexibleLoadMeasures"][0]["reward"]

                if new_profile == old_profile and new_flex_load_id == old_flex_load_id and new_reward == old_reward:
                    print("No new measure to create, identical measure found.")
                    return

    # If no identical measure is found, create a new one
    print("New measure created!")
    with open(os.path.join(measures_folder, 'efdm_measure_%d.json' % measures_counter), 'w') as file:
        file.write(new_data)
    measures_counter += 1


# efdm logic fun: this looks at electricity prices or ws percentage to generate an efdm file with fitting timestamps, currently configured to run the load for 5h, no gradient when switching
async def efdm_from_ws_percentage(flexLoad_index):
    # specify datetimes for on and off:
    today = date.today()
    on_time = datetime(today.year, today.month, today.day, 13, 0, 0, tzinfo=timezone.utc)
    off_time = on_time + timedelta(minutes=3)
    print('start')
    print(on_time)
    print(off_time)

    gen_efdm(flexLoad_index, 1, on_time, 0, off_time, 500)

    global DA_WS_Percentage

    timeframes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]

    pick_timeframes_dict = dict(zip(timeframes, DA_WS_Percentage))
    # print(pick_timeframes_dict)

    # randomized dict for testing:
    # pick_timeframes_dict = {1: 0.4524574855890962, 2: 0.5334030242621676, 3: 0.38951002669372806, 4: 0.42912759143125634, 5: 0.3718076992471337, 6: 0.5080841486380966, 7: 0.5215203758017979, 8: 0.3969925341597408, 9: 0.5080841486380966, 10: 0.5332431714444418, 11: 0.36418201898298574, 12: 0.4143951205304367, 13: 0.3872365110769156, 14: 0.42924354243542434, 15: 0.43553787095304036, 16: 0.41210762331838563, 17: 0.48951002669372806, 18: 0.36785518553144847, 19: 0.4210554658050619, 20: 0.4237309877221917, 21: 0.5098728496634256, 22: 0.3862904720972173, 23: 0.3718076992471337, 24: 0.46483991562415156}

    i = 1
    max_sum = 0
    for i in range(1, 20):
        current_sum = pick_timeframes_dict[i] + pick_timeframes_dict[i + 1] + pick_timeframes_dict[i + 2] + \
                      pick_timeframes_dict[i + 3] + pick_timeframes_dict[i + 4]
        if current_sum >= max_sum:
            max_sum = current_sum
            start_index = i
            end_index = i + 4

        # for testing:
        # print(current_sum)
        # print(str(i) + ", " + str(i+4))

    # for testing:
    # print("result: "+ str(max_sum))
    # print(str(start_index) + ", " + str(end_index))

    # specify datetimes for on and off:
    today = date.today()
    on_time = datetime(today.year, today.month, today.day, start_index - 1, 0, 0, tzinfo=timezone.utc)

    if end_index != 24:
        off_time = datetime(today.year, today.month, today.day, end_index, 0, 0, tzinfo=timezone.utc)
    else:
        off_time = datetime(today.year, today.month, today.day + 1, 0, 0, 0, tzinfo=timezone.utc)

    gen_efdm(flexLoad_index, 6000, on_time, 0, off_time, 1000)


# efdm logic fun: this looks at electricity prices or ws percentage to generate an efdm file with fitting timestamps, currently configured to run the load for 5h, no gradient when switching

async def efdm_from_el_price(flexLoad_index):
    timeframes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]

    pick_timeframes_dict = dict(zip(timeframes, globals()['El_Price_list']))

    # for testing
    # print(pick_timeframes_dict)

    i = 1
    max_sum = 99999
    for i in range(1, 20):
        current_sum = pick_timeframes_dict[i] + pick_timeframes_dict[i + 1] + pick_timeframes_dict[i + 2] + \
                      pick_timeframes_dict[i + 3] + pick_timeframes_dict[i + 4]
        if current_sum <= max_sum:
            max_sum = current_sum
            start_index = i
            end_index = i + 4

        # for testing:
        # print(current_sum)
        # print(str(i) + ", " + str(i+4))

    # for testing:
    # print("result: "+ str(max_sum))
    # print(str(start_index) + ", " + str(end_index))

    # specify datetimes for on and off:
    today = date.today()
    on_time = datetime(today.year, today.month, today.day, start_index - 1, 0, 0, tzinfo=timezone.utc)

    if end_index != 24:
        off_time = datetime(today.year, today.month, today.day, end_index, 0, 0, tzinfo=timezone.utc)
    else:
        off_time = datetime(today.year, today.month, today.day + 1, 0, 0, 0, tzinfo=timezone.utc)

    gen_efdm(flexLoad_index, 6000, on_time, 0, off_time, 1000)

#######################################################################################################################
############################################### Anfang ################################################################
# Energie inhärent Speichern im Schichtbetrieb (8h) während der "Produktion" - Anpassung der Zeiten nach Schichtbeginn#
#######################################################################################################################

# summarized method
async def efdm_from_el_price(shift_start_hour, shift_start_minute, num_cheap_intervals=13):
    """
    Analyze electricity prices for the next 8 hours starting from the specified shift start hour.
    Start: Überprüfen der Zeiteinstellungen und welche Tankheizungen gesteuert werden sollen
    (Momentan durch Limitierung nur ein Heizstabpaar des Spültanks ansteuern). Die 13
    günstigsten Intervalle werden automatisiert anhand der aktuellen Day-Ahead-Strompreise ausgewählt.
    """
    # 15-Minuten-Strompreise
    price_list = globals().get('El_Price_list_15M', [])

    # Anzahl der Intervalle in 8 Stunden (32 Intervalle zu je 15 Minuten)
    num_intervals = 8 * 4

    # Manuell den Startzeitpunkt der Schicht festlegen
    current_time = pd.Timestamp.now(tz='Europe/Brussels')
    shift_start_time = current_time.replace(hour=shift_start_hour, minute=shift_start_minute, second=0, microsecond=0)

    # Berechne die Indizes für die 15-Minuten-Intervalle ab Schichtstartzeitpunkt
    start_index = shift_start_hour * 4
    end_index = start_index + num_intervals

    # Protokollierung der Startzeit
    print(f"Startzeitpunkt der Schicht: {shift_start_time}")

    # Prüfen, ob genügend Daten für die nächsten 8 Stunden vorhanden sind
    if len(price_list) < end_index:
        print("Nicht genügend Daten für die nächsten 8 Stunden vorhanden.")
        return

    # Durchschnittspreis über die nächsten 8 Stunden
    average_price = sum(price_list[start_index:end_index]) / num_intervals
    print(f"Durchschnittspreis über 8 Stunden: {average_price:.2f} EUR")

    # Identifiziere die günstigsten Intervalle
    price_intervals = price_list[start_index:end_index]
    cheapest_indices = sorted(range(len(price_intervals)), key=lambda i: price_intervals[i])[:num_cheap_intervals]
    print(f"Die günstigsten {num_cheap_intervals} Intervalle: {cheapest_indices}")

    # Durchlauf der 32 Intervalle ab Schichtstartzeitpunkt
    for i in range(num_intervals):
        current_price = price_intervals[i]

        # Berechne Start- und Endzeitpunkt für den IntervallflexLoad_index
        on_time = shift_start_time + timedelta(minutes=(i * 15))
        off_time = on_time + timedelta(minutes=15)
        off_time_2 = on_time + timedelta(minutes=7)

        # read current tank temperatures
        Temp_WT, Temp_ST = await read_tank_temperatures()

        # Vergleich des aktuellen Preises mit dem angepassten Durchschnittspreis - Temperaturen und Zeiten ausgeben
        print(f"Intervall {i + 1}: {on_time.strftime('%Y-%m-%d %H:%M:%S')} - {off_time.strftime('%H:%M:%S')}")
        print(f"Spültemperatur: {Temp_ST:.2f} °C")
        print(f"Waschtemperatur: {Temp_WT:.2f} °C")
        print(f"Durschnittspreis: {average_price:.2f} EUR")
        print(f"Strompreis für dieses Intervall: {current_price:.2f} EUR")

        # reward kalkulieren:
        reward = max(average_price * 0.006 - current_price * 0.006, 0)

        if Temp_ST >= 66.0:
            print("Spültanktemperatur >= 66°C, Heizstab_ST_12 bleibt unabhängig vom Preis deaktiviert")

        elif i in cheapest_indices:
            # Heizstab für 15 Minuten aktivieren
            print(f"Wir befinden uns im günstigsten Intervall.")
            print(f"Heizstab_ST_12 aktiviert von {on_time} bis {off_time} für Preis {current_price:.2f} EUR")
            # Heizstab durch gen_efdm aktivieren
            gen_efdm("Heizstab_ST_12", 1, on_time, 0, off_time, reward)
            print(f"Reward calculated: {reward:.3f} EUR")

        elif Temp_ST < 50.0:
            print(f"Temperatur unter 50°C, Heizstab wird unabhängig vom Preis aktiviert")
            print(f"Heizstab_ST_12 aktiviert von {on_time} bis {off_time_2} für Preis {current_price:.2f} EUR")
            gen_efdm("Heizstab_ST_12", 1, on_time, 0, off_time_2, reward)

        else:
            # Heizstab nicht aktivieren
            print(f"Kein Heizstab_ST_12 bei Preis {current_price:.2f} EUR")
        """
        Dürfen unter den Parametereinstellungen des Referenzprozesses nur ein Heizstabpaar
        während des Dauerbetriebs ansteuern!

        if Temp_WT < 50.0:  # on time auf 2-3 Minuten hier begrenzen?
            print(f"Temperatur unter 50°C, Heizstab wird unabhängig vom Preis aktiviert")
            print(f"Heizstab_WT_5 aktiviert von {on_time} bis {off_time} für Preis {current_price:.2f} EUR")
            gen_efdm("Heizstab_WT_5", 1, on_time, 0, off_time_2, reward)

        elif Temp_WT >= 70.0:
            print("Spültanktemperatur >= 70°C, Heizstab_WT_5 bleibt unabhängig vom Preis deaktiviert")

        elif current_price <= 0:
            # Heizstab für 15 Minuten aktivieren
            print(f"Heizstab_WT_5 aktiviert von {on_time} bis {off_time} für Preis {current_price:.2f} EUR")
            # Heizstab durch gen_efdm aktivieren
            gen_efdm("Heizstab_WT_5", 1, on_time, 0, off_time, reward)
            print(f"Reward calculated: {reward:.3f} EUR")

        else:
            # Heizstab nicht aktivieren
            print(f"Kein Heizstab_WT_5 bei Preis {current_price:.2f} EUR")
        """
        print('sleep')
        await asyncio.sleep(900)


#######################################################################################################################
############################################### Ende ##################################################################
################### Energie inhärent Speichern im Schichtbetrieb (8h) während der "Produktion"#########################
#######################################################################################################################


#######################################################################################################################
##################### Anfang Ansteuerung Verbraucher (Heizstäbe) Aufheizphase Nachts ##################################
#######################################################################################################################

# general method
async def efdm_from_Aufheizen_Nachts_EIS():
    """
    Find the cheapest 1-hour interval in the 3 hours before the shift for heating purposes.
    The interval considered is between 3:00 and 6:00 AM.
    Praxis Versuch: von 4-7 Uhr
    """

    # Get the 15-minute electricity prices
    price_list = globals().get('El_Price_list_15M', [])

    # Test, ob die korrekten Indizes verwendet werden
    # print('price 45')
    # print(price_list[45])
    # price_list[75] = -100

    # Check if there are enough prices (should be 96 for a full day)
    if len(price_list) < 96:
        print("Nicht genügend Daten für den gesamten Tag vorhanden.")
        return
    # Indizes für den Zeitraum von 4:00 bis 7:00 Uhr (3 Stunden à 4 Intervalle)
    # Überprüfe Korrektheit der Indizes
    start_index = 16  # 4:00 Uhr entspricht dem 17. Intervall (Index 16)
    end_index = 28  # 7:00 Uhr entspricht dem 29. Intervall (Index 28, nicht inklusive)

    # Sicherstellen, dass genügend Daten vorhanden sind
    if len(price_list) < end_index:
        print("Nicht genügend Daten für den Zeitraum von 4:00 bis 7:00 Uhr vorhanden.")
        return

    # Initialize variables to track the minimum cost interval
    min_cost = float('inf')
    best_interval_start_index = None

    # Schleife durch die Indizes, um das günstigste 1-Stunden-Intervall zu finden
    for i in range(start_index, end_index - 3):  # -3, da wir vier aufeinanderfolgende Intervalle benötigen
        current_cost = sum(price_list[i:i + 4])

        if current_cost < min_cost:
            min_cost = current_cost
            best_interval_start_index = i

    # Wenn ein geeignetes Intervall gefunden wurde, berechnen wir Start- und Endzeiten

    if best_interval_start_index is not None:
        best_on_time = pd.Timestamp.now(tz='Europe/Brussels').replace(hour=4, minute=0, second=0,
                                                                      microsecond=0) + timedelta(
            minutes=(best_interval_start_index - start_index) * 15)
        best_off_time = best_on_time + timedelta(hours=1)

        # Kosten des Intervalls direkt vor Schichtbeginn (5:00 bis 6:00)
        last_hour_cost = sum(price_list[end_index - 4:end_index])

        # Ensure the reward is non-negative
        reward = max((last_hour_cost - min_cost) * 0.006, 0)

        # Ausgabe der Ergebnisse
        print(
            f"Startzeitpunkt der Schicht: {pd.Timestamp.now(tz='Europe/Brussels').replace(hour=7, minute=0, second=0, microsecond=0).strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Kosten für das Intervall direkt vor Schichtbeginn: {last_hour_cost:.2f} EUR")
        print(
            f"Günstigstes Intervall gefunden: {best_on_time.strftime('%Y-%m-%d %H:%M:%S')} - {best_off_time.strftime('%H:%M:%S')}")
        print(f"Gesamtkosten des günstigsten Intervalls: {min_cost:.2f} EUR")
        print(f"Berechneter Reward: {reward:.4f} EUR")

        # Start heating and check the temperature during the interval
        current_time = best_on_time

        while current_time < best_off_time:
            # Calculate the current index in the price list for the interval
            interval_index = best_interval_start_index + ((current_time - best_on_time) // timedelta(
                minutes=15))  # tells us how many 15-minute intervals have passed sinced 'best_on_time`

            # Activate heating for the current 15-minute interval

            print(
                f"Heizstäbe Spültank aktiviert von {current_time.strftime('%H:%M')} bis {(current_time + timedelta(minutes=15)).strftime('%H:%M')} für Preis {price_list[interval_index]:.2f} EUR")
            gen_efdm("Heizstab_ST_12", 1, current_time, 0, current_time + timedelta(minutes=15), reward)
            gen_efdm("Heizstab_ST_34", 1, current_time, 0, current_time + timedelta(minutes=15), reward)
            gen_efdm("Heizstab_ST_5", 1, current_time, 0, current_time + timedelta(minutes=15), reward)

            start_times.append(current_time)
            end_times.append(current_time + timedelta(minutes=15))

            # Activate heating for the current 15-minute interval
            print(
                f"Heizstäbe Waschtank aktiviert von {current_time.strftime('%H:%M')} bis {(current_time + timedelta(minutes=15)).strftime('%H:%M')} für Preis {price_list[interval_index]:.2f} EUR")
            gen_efdm("Heizstab_WT_12", 1, current_time, 0, current_time + timedelta(minutes=15), reward)
            gen_efdm("Heizstab_WT_34", 1, current_time, 0, current_time + timedelta(minutes=15), reward)
            gen_efdm("Heizstab_WT_5", 1, current_time, 0, current_time + timedelta(minutes=15), reward)

            # Move to the next 15-minute interval
            current_time += timedelta(minutes=15)

    else:
        print("Kein geeignetes Intervall gefunden.")


async def stop_HS_temp():
    # Read tank temperatures
    Temp_WT, Temp_ST = await read_tank_temperatures()

    on_time = pd.Timestamp.now(tz='Europe/Brussels')
    off_time = pd.Timestamp.now(tz='Europe/Brussels') + timedelta(minutes=2)

    # Check the temperature and control the heating
    if Temp_ST >= 67.0:
        print("Zieltemperatur von 67°C erreicht, Heizstäbe Spültank werden deaktiviert")
        gen_efdm("Heizstab_ST_12", 1, on_time, 0, off_time, 10)
        gen_efdm("Heizstab_ST_34", 1, on_time, 0, off_time, 10)
        gen_efdm("Heizstab_ST_5", 1, on_time, 0, off_time, 10)
    else:
        print("Heizstäbe Spültank müssen nicht ausgeschaltet werden")

    # Check the temperature and control the heating
    if Temp_WT >= 67.0:
        print("Zieltemperatur von 67°C erreicht, Heizstäbe Waschtank werden deaktiviert")
        gen_efdm("Heizstab_WT_12", 1, on_time, 0, off_time, 10)
        gen_efdm("Heizstab_WT_34", 1, on_time, 0, off_time, 10)
        gen_efdm("Heizstab_WT_5", 1, on_time, 0, off_time, 10)
    else:
        print("Heizstäbe Waschtank müssen nicht ausgeschaltet werden")


async def check_temp_bef_start():
    await asyncio.sleep(9900)
    # final temperature check 15 minutes before the shift starts
    Temp_WT, Temp_ST = await read_tank_temperatures()

    if Temp_ST < 50.0:
        print("Temperatur vor Schichtbeginn unter 50°C, Heizstab wird für 2 Minuten aktiviert")
        gen_efdm("Heizstab_ST_12", 1, final_check_time, 0, final_check_time + timedelta(minutes=2), 10)
        gen_efdm("Heizstab_ST_34", 1, final_check_time, 0, final_check_time + timedelta(minutes=2), 10)
        gen_efdm("Heizstab_ST_5", 1, final_check_time, 0, final_check_time + timedelta(minutes=2), 10)
    else:
        print("Temperatur vor Schichtbeginn >= 50°C, keine weitere Aktion erforderlich")

    if Temp_WT < 50.0:
        print("Temperatur vor Schichtbeginn unter 50°C, Heizstäbe werden für 2 Minuten aktiviert")
        gen_efdm("Heizstab_WT_12", 1, final_check_time, 0, final_check_time + timedelta(minutes=2), 10)
        gen_efdm("Heizstab_WT_34", 1, final_check_time, 0, final_check_time + timedelta(minutes=2), 10)
        gen_efdm("Heizstab_WT_5", 1, final_check_time, 0, final_check_time + timedelta(minutes=2), 10)
    else:
        print("Temperatur vor Schichtbeginn >= 50°C, keine weitere Aktion erforderlich")


#######################################################################################################################
# Ende Ansteuerung Verbraucher (Heizstäbe) Aufheizphase Nachts ########################################################
#######################################################################################################################

#######################################################################################################################
# Anfang Ansteuerung Verbraucher (Heizstäbe) Aufheizphase Tagsueber ###################################################
#######################################################################################################################

# summarized method
async def efdm_from_Aufheizen_Tagsueber_EIS():
    """
    Find the cheapest 1-hour interval in the 3 hours before the shift for heating purposes.
    The interval considered is between 11:00 and 14:00.
    """

    # Get the 15-minute electricity prices
    price_list = globals().get('El_Price_list_15M', [])

    # Test, ob die korrekten Indizes verwendet werden
    # print('price 44')
    # print(price_list[44])

    # Check if there are enough prices (should be 96 for a full day)
    if len(price_list) < 96:
        print("Nicht genügend Daten für den gesamten Tag vorhanden.")
        return
    # Indizes für den Zeitraum von 11:00 bis 14:00 Uhr (3 Stunden à 4 Intervalle)
    # Überprüfe Korrektheit der Indizes
    start_index = 44  # 11:00 Uhr entspricht dem 45. Intervall (Index 44)
    end_index = 56  # 14:00 Uhr entspricht dem 57. Intervall (Index 56, nicht inklusive)

    # Sicherstellen, dass genügend Daten vorhanden sind
    if len(price_list) < end_index:
        print("Nicht genügend Daten für den Zeitraum von 11:00 bis 14:00 Uhr vorhanden.")
        return

    # Initialize variables to track the minimum cost interval
    min_cost = float('inf')
    best_interval_start_index = None

    # Schleife durch die Indizes, um das günstigste 1-Stunden-Intervall zu finden
    for i in range(start_index, end_index - 3):  # -3, da wir vier aufeinanderfolgende Intervalle benötigen
        current_cost = sum(price_list[i:i + 4])

        if current_cost < min_cost:
            min_cost = current_cost
            best_interval_start_index = i

    # Wenn ein geeignetes Intervall gefunden wurde, berechnen wir Start- und Endzeiten

    if best_interval_start_index is not None:
        best_on_time = pd.Timestamp.now(tz='Europe/Brussels').replace(hour=11, minute=0, second=0,
                                                                      microsecond=0) + timedelta(
            minutes=(best_interval_start_index - start_index) * 15)
        best_off_time = best_on_time + timedelta(hours=1)

        # Kosten des Intervalls direkt vor Schichtbeginn (13:00 bis 14:00)
        last_hour_cost = sum(price_list[end_index - 4:end_index])

        # Ensure the reward is non-negative
        reward = max((last_hour_cost - min_cost) * 0.006, 0)

        # Ausgabe der Ergebnisse
        print(
            f"Startzeitpunkt der Schicht: {pd.Timestamp.now(tz='Europe/Brussels').replace(hour=14, minute=0, second=0, microsecond=0).strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Kosten für das Intervall direkt vor Schichtbeginn: {last_hour_cost:.2f} EUR")
        print(
            f"Günstigstes Intervall gefunden: {best_on_time.strftime('%Y-%m-%d %H:%M:%S')} - {best_off_time.strftime('%H:%M:%S')}")
        print(f"Gesamtkosten des günstigsten Intervalls: {min_cost:.2f} EUR")
        print(f"Berechneter Reward: {reward:.4f} EUR")

        # Start heating and check the temperature during the interval
        current_time = best_on_time

        while current_time < best_off_time:
            # Calculate the current index in the price list for the interval
            interval_index = best_interval_start_index + ((current_time - best_on_time) // timedelta(
                minutes=15))  # tells us how many 15-minute intervals have passed sinced 'best_on_time`

            # Activate heating for the current 15-minute interval
            # minutes_duration = 15
            print(
                f"Heizstäbe Spültank aktiviert von {current_time.strftime('%H:%M')} bis {(current_time + timedelta(minutes=15)).strftime('%H:%M')} für Preis {price_list[interval_index]:.2f} EUR")
            gen_efdm("Heizstab_ST_12", 1, current_time, 0, current_time + timedelta(minutes=15), reward)
            gen_efdm("Heizstab_ST_34", 1, current_time, 0, current_time + timedelta(minutes=15), reward)
            gen_efdm("Heizstab_ST_5", 1, current_time, 0, current_time + timedelta(minutes=15), reward)

            start_times.append(current_time)
            end_times.append(current_time + timedelta(minutes=15))

            # Activate heating for the current 15-minute interval
            print(
                f"Heizstäbe Waschtank aktiviert von {current_time.strftime('%H:%M')} bis {(current_time + timedelta(minutes=15)).strftime('%H:%M')} für Preis {price_list[interval_index]:.2f} EUR")
            gen_efdm("Heizstab_WT_12", 1, current_time, 0, current_time + timedelta(minutes=15), reward)
            gen_efdm("Heizstab_WT_34", 1, current_time, 0, current_time + timedelta(minutes=15), reward)
            gen_efdm("Heizstab_WT_5", 1, current_time, 0, current_time + timedelta(minutes=15), reward)

            # Move to the next 15-minute interval
            current_time += timedelta(minutes=15)

    else:
        print("Kein geeignetes Intervall gefunden.")


#######################################################################################################################
######################### Ende Ansteuerung Verbraucher (Heizstäbe) Aufheizphase Tagsueber #############################
#######################################################################################################################

#######################################################################################################################
##################### Bivalentes Aufheizen - Entscheidung zwischen rotem Netz und Heizstäben ##########################
#######################################################################################################################

# general method
async def efdm_from_Bivalent_Aufheizen():
    """
    Find the cheapest 1-hour interval in the 3 hours before the shift for heating purposes.
    The interval considered is between 3:00 and 6:00 AM.
    Praxis Versuch: von 4-7 Uhr
    Compare the costs for heating via the red network with the costs for heating via the heating rods
    Heat up with the method which is cheaper
    """

    # Get the 15-minute electricity prices
    price_list = globals().get('El_Price_list_15M', [])

    # Test, ob die korrekten Indizes verwendet werden
    # print('price 45')
    # print(price_list[45])
    # price_list[75] = -100

    # Check if there are enough prices (should be 96 for a full day)
    if len(price_list) < 96:
        print("Nicht genügend Daten für den gesamten Tag vorhanden.")
        return
    # Indizes für den Zeitraum von 4:00 bis 7:00 Uhr (3 Stunden à 4 Intervalle)
    # Überprüfe Korrektheit der Indizes
    start_index = 16  # 4:00 Uhr entspricht dem 17. Intervall (Index 16)
    end_index = 28  # 7:00 Uhr entspricht dem 29. Intervall (Index 28, nicht inklusive)

    # Sicherstellen, dass genügend Daten vorhanden sind
    if len(price_list) < end_index:
        print("Nicht genügend Daten für den Zeitraum von 4:00 bis 7:00 Uhr vorhanden.")
        return

    # Initialize variables to track the minimum cost interval
    min_cost = float('inf')
    best_interval_start_index = None

    # Schleife durch die Indizes, um das günstigste 1-Stunden-Intervall zu finden
    for i in range(start_index, end_index - 3):  # -3, da wir vier aufeinanderfolgende Intervalle benötigen
        current_cost = sum(price_list[i:i + 4])

        if current_cost < min_cost:
            min_cost = current_cost
            best_interval_start_index = i

    # Wenn ein geeignetes Intervall gefunden wurde, berechnen wir Start- und Endzeiten

    if best_interval_start_index is not None:
        best_on_time = pd.Timestamp.now(tz='Europe/Brussels').replace(hour=4, minute=0, second=0,
                                                                      microsecond=0) + timedelta(
            minutes=(best_interval_start_index - start_index) * 15)
        best_off_time = best_on_time + timedelta(hours=1)

        # Kosten des Intervalls direkt vor Schichtbeginn (5:00 bis 6:00)
        last_hour_cost = sum(price_list[end_index - 4:end_index])

        # Ensure the reward is non-negative
        reward = max((last_hour_cost - min_cost) * 0.006, 0)

        # Ausgabe der Ergebnisse
        print(
            f"Startzeitpunkt der Schicht: {pd.Timestamp.now(tz='Europe/Brussels').replace(hour=7, minute=0, second=0, microsecond=0).strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Kosten für das Intervall direkt vor Schichtbeginn: {last_hour_cost:.2f} EUR")
        print(
            f"Günstigstes Intervall gefunden: {best_on_time.strftime('%Y-%m-%d %H:%M:%S')} - {best_off_time.strftime('%H:%M:%S')}")
        print(f"Gesamtkosten des günstigsten Intervalls: {min_cost:.2f} EUR")
        print(f"Berechneter Reward: {reward:.4f} EUR")

        # Berechnung der Heizstabkosten
        heizstab_kosten = min_cost * 0.06 * 0.5 # Preis pro MWh mal 0,06 MW mal 0,5 Stunden
        print(f"Kosten für das Aufheizen mit den Heizstäben: {heizstab_kosten:.2f}EUR")

        # Vergleich der Kosten zwischen Heizstäben und rotem Netz
        kosten_rotes_netz = 7.41

        if heizstab_kosten < kosten_rotes_netz:
            print("Aufheizen über die Heizstäbe ist günstiger")
            # Weiter mit dem bestehenden Algorithmus für Heizstäbe

            # Start heating and check the temperature during the interval
            current_time = best_on_time

            while current_time < best_off_time:
                # Calculate the current index in the price list for the interval
                interval_index = best_interval_start_index + ((current_time - best_on_time) // timedelta(
                    minutes=15))  # tells us how many 15-minute intervals have passed sinced 'best_on_time`

                # Activate heating for the current 15-minute interval

                print(
                    f"Heizstäbe Spültank aktiviert von {current_time.strftime('%H:%M')} bis {(current_time + timedelta(minutes=15)).strftime('%H:%M')} für Preis {price_list[interval_index]:.2f} EUR")
                gen_efdm("Heizstab_ST_12", 1, current_time, 0, current_time + timedelta(minutes=15), reward)
                gen_efdm("Heizstab_ST_34", 1, current_time, 0, current_time + timedelta(minutes=15), reward)
                gen_efdm("Heizstab_ST_5", 1, current_time, 0, current_time + timedelta(minutes=15), reward)

                start_times.append(current_time)
                end_times.append(current_time + timedelta(minutes=15))

                # Activate heating for the current 15-minute interval
                print(
                    f"Heizstäbe Waschtank aktiviert von {current_time.strftime('%H:%M')} bis {(current_time + timedelta(minutes=15)).strftime('%H:%M')} für Preis {price_list[interval_index]:.2f} EUR")
                gen_efdm("Heizstab_WT_12", 1, current_time, 0, current_time + timedelta(minutes=15), reward)
                gen_efdm("Heizstab_WT_34", 1, current_time, 0, current_time + timedelta(minutes=15), reward)
                gen_efdm("Heizstab_WT_5", 1, current_time, 0, current_time + timedelta(minutes=15), reward)

                # Move to the next 15-minute interval
                current_time += timedelta(minutes=15)

        else:
            print("Aufheizen über das rote Netz ist günstiger.")
            # Funktion zum bivalenten Aufheizen aktivieren
            bivalent_betreiben_aktivieren()
    else:
        print("Kein geeignetes Intervall gefunden.")


async def stop_HS_temp_RN():
    # Read tank temperatures
    Temp_WT, Temp_ST = await read_tank_temperatures()

    if Temp_ST >= 67.0:
        print("Zieltemperatur von 67°C erreicht, Aufheizen über rotes Netz deaktivieren")
        bivalent_betreiben_deaktivieren()
    else:
        print("Aufheizen über das rote Netz muss nicht deaktiviert werden")

    if Temp_WT >= 67.0:
        print("Zieltemperatur von 67°C erreicht, Aufheizen über rotes Netz deaktivieren")
        bivalent_betreiben_deaktivieren()
    else:
        print("Aufheizen über das rote Netz muss nicht deaktiviert werden")

########################################################################################################################
###############################Ende bivalentes Aufheizen################################################################
########################################################################################################################

#######################################################################opc ua server funs start

# initialize server - set security and load information models, then load datatypes from these models
async def opcua_central_server_init():
    await server.init()
    server.set_endpoint(server_url)
    server.set_server_name('Energy Flexibility Central Server ETA')
    server.set_security_policy(
        [
            ua.SecurityPolicyType.NoSecurity,
            # ua.SecurityPolicyType.Basic256Sha256_SignAndEncrypt,
            # ua.SecurityPolicyType.Basic256Sha256_Sign,
        ]
    )

    # Load information models from respective XML file
    await server.import_xml(DI_path)
    print(colored('DI loaded', 'green'))
    await server.import_xml(IA_path)
    print(colored('IA loaded', 'green'))
    await server.import_xml(Machinery_path)
    print(colored('Machinery loaded', 'green'))
    await server.import_xml(MT_path)
    print(colored('MT loaded', 'green'))
    await server.import_xml(CO2_path)
    print(colored('CO2 loaded', 'green'))
    await server.import_xml(EnFlex_path)
    print(colored('EnFlex loaded', 'green'))
    await server.import_xml(CentralServer_path)
    print(colored('CentralServer nodeset loaded', 'green'))

    # load type defs from imported nodesets
    await server.load_data_type_definitions()
    await server.start()

    # create node objects from relevant nodes of Energy_generation_dict:
    for k, v in Energy_generation_dict.items():
        globals()['CentralServer_N_' + k] = server.get_node(globals()['CentralServer_id_' + k])

    # create node objects from relevant nodes of Energy_share_dict:
    for k, v in Energy_share_dict.items():
        globals()['CentralServer_N_' + k] = server.get_node(globals()['CentralServer_id_' + k])

    # create node object for total carbon emission factor:
    globals()['CentralServer_N_total_carbon_emission_factor'] = server.get_node(ua.NodeId(6009, 8))

    # create node object for total energy generation:
    globals()['CentralServer_N_total_energy_generation'] = server.get_node(ua.NodeId(6010, 8))

    # create node objects from relevant nodes of tf_start_dict:
    for k, v in tf_start_dict.items():
        globals()['CentralServer_N_' + k] = server.get_node(globals()['CentralServer_id_' + k])

    # create node objects from relevant nodes of tf_price_dict:
    for k, v in tf_price_dict.items():
        globals()['CentralServer_N_' + k] = server.get_node(globals()['CentralServer_id_' + k])

    # create node objects from relevant nodes of tf_end_dict:
    for k, v in tf_end_dict.items():
        globals()['CentralServer_N_' + k] = server.get_node(globals()['CentralServer_id_' + k])

    # create node objects from relevant nodes of tf_TotalGen_dict:
    for k, v in tf_TotalGen_dict.items():
        globals()['CentralServer_N_' + k] = server.get_node(globals()['CentralServer_id_' + k])

    # create node objects from relevant nodes of tf_WSGen_dict:
    for k, v in tf_WSGen_dict.items():
        globals()['CentralServer_N_' + k] = server.get_node(globals()['CentralServer_id_' + k])

    # create node objects from relevant nodes of tf_WSPercent_dict:
    for k, v in tf_WSPercent_dict.items():
        globals()['CentralServer_N_' + k] = server.get_node(globals()['CentralServer_id_' + k])

    # set the timestamps of the DA timeframes
    today = date.today()

    # read node values, replace and write for start of tf
    for k, v in tf_start_dict.items():
        TS_Val = await globals()['CentralServer_N_' + k].read_value()
        TS_Val = TS_Val.replace(year=today.year, month=today.month, day=today.day)
        await globals()['CentralServer_N_' + k].set_value(TS_Val)

    # read node values, replace and write for end of tf, deal with last timeframe ending on next day
    for k, v in tf_end_dict.items():
        TS_Val = await globals()['CentralServer_N_' + k].read_value()
        if globals()['CentralServer_N_' + k].nodeid.Identifier != 6154:
            TS_Val = TS_Val.replace(year=today.year, month=today.month, day=today.day)
        else:
            TS_Val = TS_Val.replace(year=today.year, month=today.month, day=today.day + 1)
        await globals()['CentralServer_N_' + k].set_value(TS_Val)

    print('Server started, listening on ' + server_url)


# Logging einrichten
logging.basicConfig(level=logging.INFO, filename='script.log', format='%(asctime)s %(levelname)s: %(message)s')


# Main coro
async def main():
    print('')
    print(
        '########################################################################################################################')
    print(
        'This is the ETA central server, which provides EFDM measures to energy flexible machines and conncets to the entso-e API')
    print(
        '########################################################################################################################')
    try:
        await opcua_central_server_init()

        # Einzustellen vor der Umsetzung der Maßnahmen:
        # In Main-Schleife nur die Fuktion entkommentieren die aktiviert werden soll
        # final_check_time auch die richtige Uhrzeit setzen
        # starte 'check_temp_bef_start' als separate asynchrone Aufgabe



        # asyncio.create_task(check_temp_bef_start())

        # i = 0
        while True:
            print('server running...')
            await asyncio.sleep(1)
            try:
                await CurrentMix_updater()
            except:
                print("Failed to update psr types")
            try:
                await query_DayAhead_prices()
            except:
                print("Failed to update day ahead prices")
            try:
                await query_Generation()
            except:
                print("Failed to update day ahead total generation")
            try:
                await query_WindSolar()
            except:
                print("Failed to update day ahead total wind and solar genartion")

                # Durchlaufbetrieb EIS

            try:
                await efdm_from_el_price(14, 00)

            except Exception as e:
                print("failed to create efdm measure file because Entso-E failed to provide enough data")
                print(e)

                # Aufheizen Nachts
            """
            try:
                await efdm_from_Aufheizen_Nachts_EIS()
                logging.info(f"start_times: {start_times}")
                logging.info(f"end_times: {end_times}")
                print("start_times")
                print(start_times)
                print("end_times")
                print(end_times)

                for start_time in start_times:
                    while pd.Timestamp.now(tz='Europe/Brussels') <= start_time + timedelta(minutes=-1):
                        try:
                            await stop_HS_temp()
                        except Exception as e:
                            logging.error(f"Fehler in stop_HS_temp: {e}")
                        await asyncio.sleep(150)

                # await asyncio.sleep(30)
                # await check_temp_bef_start()

            except Exception as e:
                print("failed to create efdm measure file because Entso-E failed to provide enough data")
                print(e)

            """
            # Aufheizen Tagsüber
            """
            try:
                await efdm_from_Aufheizen_Tagsueber_EIS()
                logging.info(f"start_times: {start_times}")
                logging.info(f"end_times: {end_times}")
                print("start_times")
                print(start_times)
                print("end_times")
                print(end_times)

                for start_time in start_times:
                    while pd.Timestamp.now(tz='Europe/Brussels') <= start_time + timedelta(minutes=-1):
                        try:
                            await stop_HS_temp()
                        except Exception as e:
                            logging.error(f"Fehler in stop_HS_temp: {e}")
                        await asyncio.sleep(960)





                # await asyncio.sleep(30)
                # await check_temp_bef_start()

            except Exception as e:
                print("failed to create efdm measure file because Entso-E failed to provide enough data")
                print(e)
            """

            # Bivalentes Aufheizen
            """
            try:
                await efdm_from_Bivalent_Aufheizen()
                logging.info(f"start_times: {start_times}")
                logging.info(f"end_times: {end_times}")
                print("start_times")
                print(start_times)
                print("end_times")
                print(end_times)

                for start_time in start_times:
                    while pd.Timestamp.now(tz='Europe/Brussels') <= start_time + timedelta(minutes=-1):
                        try:
                            await stop_HS_temp_RN()
                        except Exception as e:
                            logging.error(f"Fehler in stop_HS_temp_RN: {e}")
                        await asyncio.sleep(960)

                # await asyncio.sleep(30)
                # await check_temp_bef_start()

            except Exception as e:
                print("failed to create efdm measure file because Entso-E failed to provide enough data")
                print(e)
            """

            # for testing:
            # print(DA_WS_Percentage)
            # i+=1
            # globals()['ElMix_start'] = pd.Timestamp.now(tz='Europe/Brussels').replace(hour=i,minute=0,second=0,microsecond=0,nanosecond=0) + timedelta(days=-4, hours=-1) #days -5 while testing on weekend / hours-5
            # globals()['ElMix_end'] = pd.Timestamp.now(tz='Europe/Brussels').replace(hour=i,minute=0,second=0,microsecond=0,nanosecond=0) + timedelta(days=-4, hours=+1)

            await asyncio.sleep(15)
    except Exception as e:
        logging.critical("Kritischer Fehler in der Hauptschleife", exc_info=True)


loop = asyncio.get_event_loop()
loop.create_task(main())
loop.run_forever()


